#include "hcp_bridge.h"
#include "esphome/core/log.h"
#include "hcp2_lp_bin.h"

namespace esphome {
namespace hcp_bridge {

static const char *const TAG = "hcp_bridge";

void HCPBridge::setup() {
  ESP_LOGCONFIG(TAG, "Setting up HCP Bridge...");

  // Shared memory is at fixed address 0x50002000 in LP RAM
  shared_data_ = reinterpret_cast<hcp2::SharedData *>(0x50002000);

  // Initialize shared memory
  if (try_lock()) {
    shared_data_->owner_flag = hcp2::OWNER_FREE;
    shared_data_->command_request = hcp2::CMD_NONE;
    shared_data_->last_update_ts = 0;
    unlock();
  }

#ifdef USE_ESP32_VARIANT_ESP32C6
  ESP_LOGI(TAG, "Starting LP Core...");
  
  // Use the array generated by build_hooks.py and included from hcp2_lp_bin.h
  // lp_firmware_bin and lp_firmware_bin_size are defined there.
  esp_err_t err = ulp_lp_core_load_binary(lp_firmware_bin, lp_firmware_bin_size);
  if (err != ESP_OK) {
    ESP_LOGE(TAG, "Failed to load LP firmware: %d", err);
    return;
  }

  ulp_lp_core_cfg_t cfg = {
    .wakeup_source = ULP_LP_CORE_WAKEUP_SOURCE_HP_CPU,
  };
  err = ulp_lp_core_run(&cfg);
  if (err != ESP_OK) {
    ESP_LOGE(TAG, "Failed to run LP core: %d", err);
  }
#else
  ESP_LOGW(TAG, "LP Core only supported on ESP32-C6. Running in stub mode.");
#endif
}

void HCPBridge::loop() {
  // We don't necessarily need to lock for reading single bytes, 
  // but for consistent multi-byte reads (ts) it's safer.
  // However, LP core updates frequently, so we don't want to block HP loop.
  // We'll just read directly since it's most efficient and mostly safe for single fields.
}

void HCPBridge::dump_config() {
  ESP_LOGCONFIG(TAG, "HCP Bridge:");
  ESP_LOGCONFIG(TAG, "  Shared Memory Address: %p", shared_data_);
}

bool HCPBridge::try_lock() {
  if (shared_data_->owner_flag == hcp2::OWNER_FREE) {
    shared_data_->owner_flag = hcp2::OWNER_HP;
    return true;
  }
  return false;
}

void HCPBridge::unlock() {
  shared_data_->owner_flag = hcp2::OWNER_FREE;
}

void HCPBridge::set_command(uint8_t command) {
  // Busy wait briefly for lock
  for (int i = 0; i < 100; i++) {
    if (try_lock()) {
      shared_data_->command_request = command;
      unlock();
      return;
    }
    esp_rom_delay_us(10);
  }
  ESP_LOGW(TAG, "Failed to acquire lock for command %d", command);
}

void HCPBridge::set_target_position(uint8_t position) {
  for (int i = 0; i < 100; i++) {
    if (try_lock()) {
      shared_data_->target_position = position;
      unlock();
      return;
    }
    esp_rom_delay_us(10);
  }
}

}  // namespace hcp_bridge
}  // namespace esphome